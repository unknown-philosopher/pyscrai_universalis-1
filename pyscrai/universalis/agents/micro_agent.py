"""
Micro Agent - Individual/social agents for PyScrAI Universalis.

This module implements micro-level agents with memory-driven behavior,
relationship awareness, and routine-based actions.
"""

from typing import List, Dict, Any, Optional, Set
from dataclasses import dataclass, field
from enum import Enum

from pyscrai.data.schemas.models import Actor, WorldState, ResolutionType
from pyscrai.universalis.agents.llm_controller import LanguageModel, LLMController
from pyscrai.universalis.agents.llm_provider import LangChainOpenRouterModel
from pyscrai.universalis.memory.associative import ChromaDBMemoryBank
from pyscrai.universalis.memory.scopes import (
    MemoryScope, 
    ScopeFilter,
    create_private_memory_metadata,
    create_shared_memory_metadata
)
from pyscrai.universalis.memory.stream import MemoryStream, EventType
from pyscrai.utils.logger import get_logger

logger = get_logger(__name__)


class MicroAgentState(str, Enum):
    """Internal states for micro agents."""
    IDLE = "idle"
    ACTIVE = "active"
    STRESSED = "stressed"
    FOCUSED = "focused"
    SOCIAL = "social"


@dataclass
class MicroAgentConfig:
    """Configuration for micro agents."""
    max_memory_retrieval: int = 7
    temperature: float = 0.8
    personality_influence: float = 0.5
    relationship_weight: float = 0.3
    routine_weight: float = 0.2


@dataclass
class Relationship:
    """Relationship with another agent."""
    target_id: str
    sentiment: float = 0.0  # -1.0 to 1.0
    trust: float = 0.5  # 0.0 to 1.0
    familiarity: float = 0.0  # 0.0 to 1.0
    tags: List[str] = field(default_factory=list)


@dataclass
class MicroIntent:
    """
    Intent generated by a micro agent.
    
    Attributes:
        actor_id: ID of the actor
        content: The intent description
        emotional_state: Current emotional state
        relationships_involved: IDs of other agents involved
        is_routine: Whether this is a routine action
        metadata: Additional metadata
    """
    actor_id: str
    content: str
    emotional_state: str = "neutral"
    relationships_involved: List[str] = field(default_factory=list)
    is_routine: bool = False
    metadata: Dict[str, Any] = field(default_factory=dict)


class MicroAgent:
    """
    Individual agent with memory-driven, socially-aware behavior.
    
    Micro agents simulate individual people or characters with
    personal memories, relationships, and behavioral patterns.
    """
    
    def __init__(
        self,
        actor: Actor,
        llm: Optional[LanguageModel] = None,
        memory_bank: Optional[ChromaDBMemoryBank] = None,
        memory_stream: Optional[MemoryStream] = None,
        config: Optional[MicroAgentConfig] = None
    ):
        """
        Initialize the micro agent.
        
        Args:
            actor: The Actor model this agent represents
            llm: Language model for decision making
            memory_bank: Optional memory bank for long-term memory
            memory_stream: Optional event stream for traceability
            config: Agent configuration
        """
        self.actor = actor
        self.config = config or MicroAgentConfig()
        
        # Initialize LLM
        if llm is None:
            self._llm = LangChainOpenRouterModel(temperature=self.config.temperature)
        else:
            self._llm = llm
        
        self._memory_bank = memory_bank
        self._memory_stream = memory_stream
        self._llm_controller = LLMController(self._llm)
        
        # Internal state
        self._state = MicroAgentState.IDLE
        self._relationships: Dict[str, Relationship] = {}
        self._recent_interactions: List[str] = []
        self._groups: Set[str] = set()
        
        # Create scope filter for memory retrieval
        self._scope_filter = ScopeFilter(
            agent_id=actor.actor_id,
            groups=self._groups,
            include_public=True
        )
        
        logger.info(f"MicroAgent initialized for {actor.actor_id} ({actor.role})")
    
    def add_relationship(
        self,
        target_id: str,
        sentiment: float = 0.0,
        trust: float = 0.5,
        tags: Optional[List[str]] = None
    ) -> None:
        """
        Add or update a relationship with another agent.
        
        Args:
            target_id: ID of the other agent
            sentiment: Sentiment score (-1.0 to 1.0)
            trust: Trust level (0.0 to 1.0)
            tags: Relationship tags (e.g., "family", "colleague")
        """
        self._relationships[target_id] = Relationship(
            target_id=target_id,
            sentiment=max(-1.0, min(1.0, sentiment)),
            trust=max(0.0, min(1.0, trust)),
            tags=tags or []
        )
    
    def join_group(self, group_id: str) -> None:
        """Join a group for shared memory access."""
        self._groups.add(group_id)
        self._scope_filter = ScopeFilter(
            agent_id=self.actor.actor_id,
            groups=self._groups,
            include_public=True
        )
    
    def perceive(self, world_state: WorldState) -> Dict[str, Any]:
        """
        Perceive the current world state with personal context.
        
        Args:
            world_state: Current world state
        
        Returns:
            Perception context dict with personal elements
        """
        env = world_state.environment
        
        # Build base context
        context = {
            "cycle": env.cycle,
            "time": env.time,
            "weather": env.weather,
            "recent_events": env.global_events[-3:] if env.global_events else [],
            "state": self._state.value,
            "relationships": self._get_relationship_context(world_state),
            "memories": [],
            "recent_interactions": self._recent_interactions[-5:]
        }
        
        # Retrieve relevant personal memories
        if self._memory_bank:
            # Build a personal query based on current context
            query_parts = [
                self.actor.description,
                f"current situation: {env.weather}",
            ]
            if env.global_events:
                query_parts.append(env.global_events[-1])
            
            query = " ".join(query_parts)
            
            memories = self._memory_bank.retrieve_associative(
                query,
                k=self.config.max_memory_retrieval,
                scope_filter=self._scope_filter
            )
            context["memories"] = list(memories)
        
        return context
    
    def _get_relationship_context(
        self, 
        world_state: WorldState
    ) -> List[Dict[str, Any]]:
        """Get context about relevant relationships."""
        rel_context = []
        
        for target_id, rel in self._relationships.items():
            if target_id in world_state.actors:
                target = world_state.actors[target_id]
                rel_context.append({
                    "id": target_id,
                    "role": target.role,
                    "sentiment": rel.sentiment,
                    "trust": rel.trust,
                    "tags": rel.tags
                })
        
        return rel_context
    
    def generate_intent(
        self,
        world_state: WorldState,
        context: Optional[Dict[str, Any]] = None
    ) -> MicroIntent:
        """
        Generate an intent based on personal context and memories.
        
        Args:
            world_state: Current world state
            context: Optional pre-computed perception context
        
        Returns:
            MicroIntent with the agent's decision
        """
        if context is None:
            context = self.perceive(world_state)
        
        # Build the prompt with personal elements
        prompt = self._build_intent_prompt(context)
        
        # Generate intent using LLM
        try:
            response = self._llm_controller.generate(
                prompt,
                temperature=self.config.temperature
            )
            
            # Detect if this involves relationships
            relationships_involved = []
            for rel in context["relationships"]:
                if rel["role"].lower() in response.lower() or rel["id"].lower() in response.lower():
                    relationships_involved.append(rel["id"])
            
            intent = MicroIntent(
                actor_id=self.actor.actor_id,
                content=response,
                emotional_state=self._state.value,
                relationships_involved=relationships_involved,
                metadata={
                    "cycle": context["cycle"],
                    "memory_count": len(context.get("memories", []))
                }
            )
            
            # Store the decision in personal memory
            if self._memory_bank:
                self._memory_bank.add(
                    f"[Cycle {context['cycle']}] I decided: {response}",
                    scope=MemoryScope.PRIVATE,
                    owner_id=self.actor.actor_id,
                    cycle=context["cycle"],
                    importance=0.6
                )
            
            # Log to event stream
            if self._memory_stream:
                self._memory_stream.add_intent(
                    content=response,
                    cycle=context["cycle"],
                    actor_id=self.actor.actor_id,
                    metadata={"emotional_state": self._state.value}
                )
            
            logger.info(f"{self.actor.actor_id} generated intent: {response[:50]}...")
            return intent
            
        except Exception as e:
            logger.error(f"Error generating intent for {self.actor.actor_id}: {e}")
            return MicroIntent(
                actor_id=self.actor.actor_id,
                content=f"Error: {str(e)}",
                emotional_state="confused"
            )
    
    def _build_intent_prompt(self, context: Dict[str, Any]) -> str:
        """Build a personal, character-driven prompt."""
        # Format memories as personal experiences
        memories_str = ""
        if context["memories"]:
            memories_str = "\n\nYour relevant memories:\n- " + "\n- ".join(context["memories"])
        
        # Format relationships
        relationships_str = ""
        if context["relationships"]:
            rel_lines = []
            for rel in context["relationships"]:
                sentiment_word = "positive" if rel["sentiment"] > 0.3 else "negative" if rel["sentiment"] < -0.3 else "neutral"
                rel_lines.append(f"  - {rel['role']}: {sentiment_word} feelings, trust level {rel['trust']:.1f}")
            relationships_str = "\n\nPeople you know:\n" + "\n".join(rel_lines)
        
        # Format recent events
        events_str = "\n- ".join(context["recent_events"]) if context["recent_events"] else "Nothing notable"
        
        # Format objectives personally
        objectives_str = ""
        if self.actor.objectives:
            objectives_str = "\n\nWhat's on your mind:\n- " + "\n- ".join(self.actor.objectives)
        
        prompt = f"""You are {self.actor.role}.
{self.actor.description}

Current time: {context['time']}
Weather: {context['weather']}
You're feeling: {context['state']}

What's happening around you:
- {events_str}
{memories_str}
{relationships_str}
{objectives_str}

Based on who you are and what you're experiencing, what do you decide to do right now?
Think about your personal needs, relationships, and current situation.
Be natural and in-character. What would YOU do?"""

        return prompt
    
    def store_observation(
        self,
        observation: str,
        cycle: int,
        importance: float = 0.5,
        emotional_impact: Optional[str] = None
    ) -> None:
        """
        Store an observation as a personal memory.
        
        Args:
            observation: What was observed
            cycle: Current simulation cycle
            importance: How important this is to remember
            emotional_impact: Optional emotional response
        """
        if self._memory_bank:
            # Make it personal
            personal_obs = f"I noticed: {observation}"
            if emotional_impact:
                personal_obs += f" (This made me feel {emotional_impact})"
            
            self._memory_bank.add(
                personal_obs,
                scope=MemoryScope.PRIVATE,
                owner_id=self.actor.actor_id,
                cycle=cycle,
                importance=importance
            )
        
        if self._memory_stream:
            self._memory_stream.add_observation(
                content=observation,
                cycle=cycle,
                actor_id=self.actor.actor_id,
                metadata={"emotional_impact": emotional_impact}
            )
    
    def record_interaction(
        self,
        other_actor_id: str,
        interaction: str,
        cycle: int,
        sentiment_change: float = 0.0
    ) -> None:
        """
        Record an interaction with another agent.
        
        Args:
            other_actor_id: ID of the other agent
            interaction: Description of the interaction
            cycle: Current simulation cycle
            sentiment_change: How this affected sentiment
        """
        self._recent_interactions.append(f"{other_actor_id}: {interaction}")
        
        # Update relationship if exists
        if other_actor_id in self._relationships:
            rel = self._relationships[other_actor_id]
            rel.sentiment = max(-1.0, min(1.0, rel.sentiment + sentiment_change))
            rel.familiarity = min(1.0, rel.familiarity + 0.1)
        
        # Store in memory
        if self._memory_bank:
            memory_text = f"[Cycle {cycle}] Interaction with {other_actor_id}: {interaction}"
            self._memory_bank.add(
                memory_text,
                scope=MemoryScope.PRIVATE,
                owner_id=self.actor.actor_id,
                cycle=cycle,
                importance=0.6 + abs(sentiment_change)
            )
    
    def update_state(self, new_state: MicroAgentState) -> None:
        """Update the agent's internal state."""
        old_state = self._state
        self._state = new_state
        logger.debug(f"{self.actor.actor_id} state: {old_state.value} -> {new_state.value}")


def create_micro_agent(
    actor: Actor,
    memory_bank: Optional[ChromaDBMemoryBank] = None,
    memory_stream: Optional[MemoryStream] = None,
    **kwargs
) -> MicroAgent:
    """
    Factory function to create a micro agent.
    
    Args:
        actor: The Actor model
        memory_bank: Optional memory bank
        memory_stream: Optional event stream
        **kwargs: Additional configuration options
    
    Returns:
        Configured MicroAgent instance
    """
    config = MicroAgentConfig(**kwargs)
    return MicroAgent(
        actor, 
        memory_bank=memory_bank, 
        memory_stream=memory_stream,
        config=config
    )

