"""
Macro Agent - Strategic/organizational agents for PyScrAI Universalis.

This module implements macro-level agents that handle policy-level
decision making, asset management, and high-level objectives.
"""

from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field

from pyscrai.data.schemas.models import Actor, WorldState, ResolutionType
from pyscrai.universalis.agents.llm_controller import LanguageModel, LLMController
from pyscrai.universalis.agents.llm_provider import LangChainOpenRouterModel
from pyscrai.universalis.memory.associative import ChromaDBMemoryBank
from pyscrai.universalis.memory.scopes import (
    MemoryScope, 
    ScopeFilter,
    create_private_memory_metadata
)
from pyscrai.utils.logger import get_logger

logger = get_logger(__name__)


@dataclass
class MacroAgentConfig:
    """Configuration for macro agents."""
    max_memory_retrieval: int = 5
    temperature: float = 0.7
    include_asset_status: bool = True
    include_objectives: bool = True


@dataclass
class MacroIntent:
    """
    Intent generated by a macro agent.
    
    Attributes:
        actor_id: ID of the actor generating the intent
        content: The intent description
        priority: Priority level (1-5, 5 being highest)
        assets_involved: List of asset IDs involved
        objectives_addressed: List of objective indices addressed
        metadata: Additional metadata
    """
    actor_id: str
    content: str
    priority: int = 3
    assets_involved: List[str] = field(default_factory=list)
    objectives_addressed: List[int] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


class MacroAgent:
    """
    Strategic agent for policy-level decision making.
    
    Macro agents operate at the organizational level, managing
    resources, making strategic decisions, and coordinating assets.
    """
    
    def __init__(
        self,
        actor: Actor,
        llm: Optional[LanguageModel] = None,
        memory_bank: Optional[ChromaDBMemoryBank] = None,
        config: Optional[MacroAgentConfig] = None
    ):
        """
        Initialize the macro agent.
        
        Args:
            actor: The Actor model this agent represents
            llm: Language model for decision making
            memory_bank: Optional memory bank for context
            config: Agent configuration
        """
        self.actor = actor
        self.config = config or MacroAgentConfig()
        
        # Initialize LLM
        if llm is None:
            self._llm = LangChainOpenRouterModel(temperature=self.config.temperature)
        else:
            self._llm = llm
        
        self._memory_bank = memory_bank
        self._llm_controller = LLMController(self._llm)
        
        # Create scope filter for memory retrieval
        self._scope_filter = ScopeFilter(
            agent_id=actor.actor_id,
            include_public=True
        )
        
        logger.info(f"MacroAgent initialized for {actor.actor_id} ({actor.role})")
    
    def perceive(self, world_state: WorldState) -> Dict[str, Any]:
        """
        Perceive the current world state.
        
        Args:
            world_state: Current world state
        
        Returns:
            Perception context dict
        """
        env = world_state.environment
        
        # Build context
        context = {
            "cycle": env.cycle,
            "time": env.time,
            "weather": env.weather,
            "recent_events": env.global_events[-3:] if env.global_events else [],
            "assets": self._get_asset_status(world_state),
            "objectives": self.actor.objectives,
            "memories": []
        }
        
        # Retrieve relevant memories if memory bank available
        if self._memory_bank:
            query = f"strategic decisions {self.actor.role} {' '.join(env.global_events[-2:] if env.global_events else [])}"
            memories = self._memory_bank.retrieve_associative(
                query,
                k=self.config.max_memory_retrieval,
                scope_filter=self._scope_filter
            )
            context["memories"] = list(memories)
        
        return context
    
    def _get_asset_status(self, world_state: WorldState) -> List[Dict[str, Any]]:
        """Get status of assets controlled by this actor."""
        assets_info = []
        for asset_id in self.actor.assets:
            if asset_id in world_state.assets:
                asset = world_state.assets[asset_id]
                assets_info.append({
                    "id": asset_id,
                    "name": asset.name,
                    "type": asset.asset_type,
                    "status": asset.status,
                    "location": asset.location,
                    "attributes": asset.attributes
                })
        return assets_info
    
    def generate_intent(
        self, 
        world_state: WorldState,
        context: Optional[Dict[str, Any]] = None
    ) -> MacroIntent:
        """
        Generate a strategic intent based on the world state.
        
        Args:
            world_state: Current world state
            context: Optional pre-computed perception context
        
        Returns:
            MacroIntent with the agent's decision
        """
        if context is None:
            context = self.perceive(world_state)
        
        # Build the prompt
        prompt = self._build_intent_prompt(context)
        
        # Generate intent using LLM
        try:
            response = self._llm_controller.generate(
                prompt,
                temperature=self.config.temperature
            )
            
            intent = MacroIntent(
                actor_id=self.actor.actor_id,
                content=response,
                assets_involved=self.actor.assets,
                metadata={
                    "cycle": context["cycle"],
                    "context_size": len(context.get("memories", []))
                }
            )
            
            # Store the decision in memory
            if self._memory_bank:
                self._memory_bank.add(
                    f"[Cycle {context['cycle']}] {self.actor.role} decided: {response}",
                    scope=MemoryScope.PRIVATE,
                    owner_id=self.actor.actor_id,
                    cycle=context["cycle"],
                    importance=0.7
                )
            
            logger.info(f"{self.actor.actor_id} generated intent: {response[:50]}...")
            return intent
            
        except Exception as e:
            logger.error(f"Error generating intent for {self.actor.actor_id}: {e}")
            return MacroIntent(
                actor_id=self.actor.actor_id,
                content=f"Error: {str(e)}",
                priority=1
            )
    
    def _build_intent_prompt(self, context: Dict[str, Any]) -> str:
        """Build the prompt for intent generation."""
        # Format objectives
        objectives_str = "\n- ".join(self.actor.objectives) if self.actor.objectives else "None specified"
        
        # Format assets
        assets_str = ""
        if self.config.include_asset_status and context["assets"]:
            asset_lines = []
            for asset in context["assets"]:
                asset_lines.append(
                    f"  - {asset['name']} ({asset['type']}): {asset['status']}"
                )
            assets_str = "\n".join(asset_lines)
        else:
            assets_str = "None"
        
        # Format recent events
        events_str = "\n- ".join(context["recent_events"]) if context["recent_events"] else "None"
        
        # Format memories
        memories_str = ""
        if context["memories"]:
            memories_str = "\n\nRelevant past experiences:\n- " + "\n- ".join(context["memories"])
        
        prompt = f"""You are {self.actor.role} (ID: {self.actor.actor_id}).
Description: {self.actor.description}

OBJECTIVES:
- {objectives_str}

ASSETS UNDER COMMAND:
{assets_str}

CURRENT SITUATION:
- Cycle: {context['cycle']}
- Time: {context['time']}
- Weather: {context['weather']}

RECENT EVENTS:
- {events_str}
{memories_str}

Based on your role, objectives, and the current situation, what is your STRATEGIC INTENT for this cycle?
Consider:
1. Which objectives are most urgent?
2. How can your assets best be utilized?
3. What coordination is needed?

Be concise and actionable. Refer to your assets by name if directing them."""

        return prompt
    
    def store_observation(
        self,
        observation: str,
        cycle: int,
        importance: float = 0.5
    ) -> None:
        """
        Store an observation in memory.
        
        Args:
            observation: The observation text
            cycle: Current simulation cycle
            importance: Importance score
        """
        if self._memory_bank:
            self._memory_bank.add(
                observation,
                scope=MemoryScope.PRIVATE,
                owner_id=self.actor.actor_id,
                cycle=cycle,
                importance=importance
            )


def create_macro_agent(
    actor: Actor,
    memory_bank: Optional[ChromaDBMemoryBank] = None,
    **kwargs
) -> MacroAgent:
    """
    Factory function to create a macro agent.
    
    Args:
        actor: The Actor model
        memory_bank: Optional memory bank
        **kwargs: Additional configuration options
    
    Returns:
        Configured MacroAgent instance
    """
    config = MacroAgentConfig(**kwargs)
    return MacroAgent(actor, memory_bank=memory_bank, config=config)

